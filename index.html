<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Conference</title>
</head>
<body>
<h2>Local Video</h2>
<video id="localVideo" muted autoplay playsinline></video>
<h2>Remote Videos</h2>
<div id="remoteVideos"></div>

<script>
    const roomId = "test-room";
    const userId = Math.random().toString(36).substr(2, 9);
    const ws = new WebSocket(`wss://82.202.137.205/ws/${roomId}/${userId}`);

    const peerConnections = {};
    const remoteVideos = document.getElementById("remoteVideos");

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –≤–∏–¥–µ–æ –∏ –∞—É–¥–∏–æ
    navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then(stream => {
            document.getElementById("localVideo").srcObject = stream;
            ws.onopen = () => {
                ws.send(JSON.stringify({ type: "join", userId }));
            };
        });

    ws.onmessage = async event => {
        const data = JSON.parse(event.data);
        console.log("üîµ –ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ WebSocket:", data);

        if (data.type === "new-user" && data.userId !== userId) {
            console.log(`üë§ –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${data.userId}`);
            createPeerConnection(data.userId, true);
        } else if (data.type === "offer" && data.to === userId) {
            console.log(`üì© –ü—Ä–∏—à—ë–ª offer –æ—Ç ${data.from}`);
            await handleOffer(data.offer, data.from);
        } else if (data.type === "answer" && data.to === userId) {
            console.log(`üì© –ü—Ä–∏—à—ë–ª answer –æ—Ç ${data.from}`);
            await peerConnections[data.from].setRemoteDescription(new RTCSessionDescription(data.answer));
        } else if (data.type === "candidate" && data.to === userId) {
            console.log(`üì° ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç –æ—Ç ${data.from}:`, data.candidate);
            await peerConnections[data.from].addIceCandidate(new RTCIceCandidate(data.candidate));
        }
    };

    function createPeerConnection(remoteUserId, initiator = false) {
        console.log(`üîß –°–æ–∑–¥–∞—ë–º peerConnection –¥–ª—è ${remoteUserId}`);

        const peerConnection = new RTCPeerConnection({
            iceServers: [
                // { urls: "stun:82.202.137.205:3478" },
                {
                    urls: "turn:82.202.137.205:3478",
                    username: "admin",
                    credential: "adminadmin"
                }
            ]
        });

        peerConnection.ontrack = event => {
            let video = document.getElementById(`video-${remoteUserId}`);
            if (!video) {
                video = document.createElement("video");
                video.id = `video-${remoteUserId}`;
                video.autoplay = true;
                video.playsInline = true;
                remoteVideos.appendChild(video);
            }
            video.srcObject = event.streams[0];
        };

        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                console.log(`üì° ICE Candidate (${remoteUserId}):`, event.candidate.candidate);
                ws.send(JSON.stringify({ type: "candidate", candidate: event.candidate, from: userId, to: remoteUserId }));
            } else {
                console.log(`‚úÖ ICE Candidate –∑–∞–≤–µ—Ä—à—ë–Ω (${remoteUserId})`);
            }
        };

        peerConnection.oniceconnectionstatechange = () => {
            console.log(`üîÑ ICE State (${remoteUserId}):`, peerConnection.iceConnectionState);
        };

        peerConnections[remoteUserId] = peerConnection;

        if (initiator) {
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
                    return peerConnection.createOffer();
                })
                .then(offer => peerConnection.setLocalDescription(offer))
                .then(() => {
                    ws.send(JSON.stringify({ type: "offer", offer: peerConnection.localDescription, to: remoteUserId, from: userId }));
                });
        }
    }

    async function handleOffer(offer, from) {
        console.log(`üé• –ü—Ä–∏–Ω–∏–º–∞–µ–º offer –æ—Ç ${from}`);

        if (!peerConnections[from]) {
            createPeerConnection(from, false);
        }

        const peerConnection = peerConnections[from];

        // if (peerConnection.signalingState !== "stable") {
        //     console.warn(`‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–æ–≤—Ç–æ—Ä–Ω—ã–π offer –æ—Ç ${from}, —Ç–∞–∫ –∫–∞–∫ signalingState = ${peerConnection.signalingState}`);
        //     return;
        // }

        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        ws.send(JSON.stringify({ type: "answer", answer: answer, to: from, from: userId }));
    }

    // –ú–µ—Ç–æ–¥ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—Å–µ—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
    function checkConnections() {
        Object.entries(peerConnections).forEach(([id, pc]) => {
            console.log(`=== Peer ${id} ===`);
            pc.getStats(null).then(stats => {
                stats.forEach(report => {
                    if (report.type === "candidate-pair" && report.nominated) {
                        console.log("üí° –ò—Å–ø–æ–ª—å–∑—É–µ–º–∞—è –ø–∞—Ä–∞ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤:", report);
                    }
                    if (report.type === "local-candidate") {
                        console.log("üü¢ –õ–æ–∫–∞–ª—å–Ω—ã–π –∫–∞–Ω–¥–∏–¥–∞—Ç:", report);
                    }
                    if (report.type === "remote-candidate") {
                        console.log("üîµ –£–¥–∞–ª—ë–Ω–Ω—ã–π –∫–∞–Ω–¥–∏–¥–∞—Ç:", report);
                    }
                });
            });
            console.log(`ICE State: ${pc.iceConnectionState}`);
        });
    }
</script>
</body>
</html>
