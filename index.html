<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Conference</title>
</head>
<body>
<h2>Local Video</h2>
<video id="localVideo" autoplay playsinline></video>
<h2>Remote Videos</h2>
<div id="remoteVideos"></div>

<script>
    const roomId = "test-room";
    const userId = Math.random().toString(36).substr(2, 9);
    const ws = new WebSocket(`wss://193.29.225.92/ws/${roomId}/${userId}`);

    const peerConnections = {};
    const remoteVideos = document.getElementById("remoteVideos");

    // Получение локального видео и аудио
    navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then(stream => {
            document.getElementById("localVideo").srcObject = stream;
            ws.onopen = () => {
                ws.send(JSON.stringify({ type: "join", userId }));
            };
        });

    ws.onmessage = async event => {
        const data = JSON.parse(event.data);

        if (data.type === "new-user" && data.userId !== userId) {
            createPeerConnection(data.userId, true);
        } else if (data.type === "offer" && data.to === userId) {
            await handleOffer(data.offer, data.from);
        } else if (data.type === "answer" && data.to === userId) {
            await peerConnections[data.from].setRemoteDescription(new RTCSessionDescription(data.answer));
        } else if (data.type === "candidate" && data.to === userId) {
            await peerConnections[data.from].addIceCandidate(new RTCIceCandidate(data.candidate));
        }
    };

    function createPeerConnection(remoteUserId, initiator = false) {
        const peerConnection = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });

        peerConnection.ontrack = event => {
            let video = document.getElementById(`video-${remoteUserId}`);
            if (!video) {
                video = document.createElement("video");
                video.id = `video-${remoteUserId}`;
                video.autoplay = true;
                video.playsInline = true;
                remoteVideos.appendChild(video);
            }
            video.srcObject = event.streams[0];
        };

        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                ws.send(JSON.stringify({ type: "candidate", candidate: event.candidate, from: userId, to: remoteUserId }));
            }
        };

        peerConnections[remoteUserId] = peerConnection;

        if (initiator) {
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
                    return peerConnection.createOffer();
                })
                .then(offer => {
                    return peerConnection.setLocalDescription(offer);
                })
                .then(() => {
                    ws.send(JSON.stringify({ type: "offer", offer: peerConnection.localDescription, to: remoteUserId, from: userId }));
                });
        }
    }

    async function handleOffer(offer, from) {
        if (!peerConnections[from]) {
            createPeerConnection(from, false);
        }

        const peerConnection = peerConnections[from];

        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        ws.send(JSON.stringify({ type: "answer", answer: answer, to: from, from: userId }));
    }

</script>
</body>
</html>
